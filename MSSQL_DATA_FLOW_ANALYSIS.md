# MSSQL Database Structure & CPQ Order Flow Analysis

**Database:** CSISTG (CSI/ERP - MSSQL Server)
**System:** Syteline ERP
**Date:** 2026-02-04
**Purpose:** Document how CPQ orders flow through MSSQL tables before import to MySQL

---

## Executive Summary

CPQ (Configure-Price-Quote) orders in the Syteline ERP system are stored across multiple related tables. The data extraction uses a **UNION query with two distinct parts**:
- **Part 1:** Captures physical items (boats, engines, accessories)
- **Part 2:** Captures configuration components from the CFG (configuration) tables

This dual approach is necessary because CPQ orders store component data differently than traditional orders. Understanding this structure is critical for proper data extraction and import.

---

## MSSQL Database Schema Overview

### Core Tables Used in Import

| Table | Purpose | Key Fields |
|-------|---------|------------|
| `coitem_mst` | Customer Order Line Items | `co_num`, `co_line`, `item`, `config_id`, `qty_invoiced` |
| `co_mst` | Customer Order Header | `co_num`, `type`, `order_date`, `external_confirmation_ref` |
| `inv_item_mst` | Invoice Line Items | `inv_num`, `co_num`, `co_line` |
| `arinv_mst` | AR Invoice Header | `inv_num`, `inv_date`, `apply_to_inv_num` |
| `item_mst` | Item Master | `item`, `description`, `product_code`, `Uf_BENN_*` fields |
| `prodcode_mst` | Product Code Lookup | `product_code`, `description` |
| `serial_mst` | Serial Numbers | `ser_num`, `ref_num`, `ref_line`, `item` |
| `cfg_attr_mst` | **Configuration Attributes** | `config_id`, `comp_id`, `attr_name`, `attr_value` |
| `cfg_comp_mst` | **Configuration Components** | `config_id`, `comp_id`, `comp_name` |

### Bennington Custom Fields (Uf_BENN_*)

The ERP has custom fields prefixed with `Uf_BENN_` (User Field - Bennington):
- `Uf_BENN_BoatSerialNumber` - Physical boat serial number
- `Uf_BENN_BoatModel` - Boat model identifier
- `Uf_BENN_BoatWebOrderNumber` - CPQ web order number
- `Uf_BENN_Series` - Boat series (Q, QX, S, R, etc.)
- `Uf_BENN_ProductCategory` - Product category code
- `Uf_BENN_MaterialCostType` - Material cost type code

---

## The Two Types of Order Items

### Type 1: Physical Items (Regular Order Lines)

**Characteristics:**
- Traditional ERP order lines
- Represent physical items (boats, engines, accessories)
- Have item numbers in `item_mst`
- Link to serial numbers in `serial_mst`
- Have individual `co_line` numbers

**Example:**
```
co_num: SO00935000
co_line: 1 → Item: 25QXFBWA (Boat hull)
co_line: 2 → Item: YAMAHA200 (Engine)
co_line: 3 → Item: 9012345 (Accessory)
```

### Type 2: Configured Items (CPQ Components)

**Characteristics:**
- Generated by CPQ configurator
- Stored in `cfg_attr_mst` and `cfg_comp_mst` tables
- Multiple components share the same `co_line` (typically 1)
- Each component has a unique `comp_id` within the `config_id`
- No traditional item numbers - identified by component names
- Store descriptive attributes in `cfg_attr_mst`

**Example:**
```
co_num: SO00936047
co_line: 1
config_id: BENN00000000000000000000000043
  ├─ comp_id: LADDER_21 → Description: "LADDER 21 NON EXT DECK"
  ├─ comp_id: 168SLJ_FURN_SB_ → Description: "168SLJ STBD BOW STANDARD"
  ├─ comp_id: S_FURN_CAPT_STD → Description: "S-RECLINER STANDARD"
  └─ ... (46 total components, all with co_line = 1)
```

---

## Data Flow: From Order Creation to MySQL Import

### Stage 1: Order Creation in CPQ

```
User configures boat in CPQ web interface
  ↓
Selects model, options, features, fabric, etc.
  ↓
CPQ generates configuration (config_id)
  ↓
Order submitted to ERP via API/integration
  ↓
ERP creates order in coitem_mst
```

**What gets created:**
- `co_mst`: Order header with `external_confirmation_ref` = CPQ order number (e.g., SOBHO00709)
- `coitem_mst`: Single line item with `config_id` populated
- `cfg_attr_mst`: Multiple rows for each configuration component
- `cfg_comp_mst`: Component definitions

### Stage 2: Invoice Creation

```
Order processed and invoiced
  ↓
inv_item_mst: Links order line to invoice
  ↓
arinv_mst: Invoice header with inv_date
  ↓
coitem_mst.qty_invoiced: Updated with invoiced quantity
```

### Stage 3: Serial Number Assignment

```
Boat manufactured (may happen before or after invoice)
  ↓
Serial number assigned (e.g., ETWC4149F425)
  ↓
serial_mst: Serial record created
  ↓
coitem_mst.Uf_BENN_BoatSerialNumber: Updated with serial
```

**⚠️ OBSERVATION:** CPQ orders in test data have **empty serial numbers** even though invoiced!

### Stage 4: MSSQL Data Extraction (Our Import Query)

```
Python script executes UNION query on MSSQL
  ↓
Part 1: Extracts physical items with serial numbers
  ↓
Part 2: Extracts configured components from CFG tables
  ↓
UNION combines both result sets
  ↓
ROW_NUMBER() generates unique LineSeqNo per order
  ↓
96 rows returned to Python
```

### Stage 5: MySQL Import

```
Python receives 96 rows in memory
  ↓
Groups by target table (BoatOptions26)
  ↓
Batch inserts (1000 rows at a time)
  ↓
ON DUPLICATE KEY UPDATE (for re-imports)
  ↓
All 96 rows inserted with unique (ERP_OrderNo, LineSeqNo)
```

---

## The UNION Query: A Deep Dive

### Part 1: Physical Items (Traditional Order Lines)

```sql
SELECT
    LEFT(coi.Uf_BENN_BoatWebOrderNumber, 30) AS [WebOrderNo],
    LEFT(im.Uf_BENN_Series, 5) AS [C_Series],
    coi.qty_invoiced AS [QuantitySold],
    LEFT(co.type, 1) AS [Orig_Ord_Type],
    LEFT(ser.ser_num, 12) AS [OptionSerialNo],
    pcm.description AS [MCTDesc],
    coi.co_line AS [LineSeqNo],               -- Original line number
    coi.co_line AS [LineNo],
    LEFT(coi.item, 15) AS [ItemNo],           -- From item_mst
    NULL AS [ItemMasterProdCatDesc],
    LEFT(im.Uf_BENN_ProductCategory, 3) AS [ItemMasterProdCat],
    LEFT(im.Uf_BENN_MaterialCostType, 10) AS [ItemMasterMCT],
    LEFT(coi.description, 30) AS [ItemDesc1],
    LEFT(iim.inv_num, 30) AS [InvoiceNo],
    CASE
        WHEN ah.inv_date IS NOT NULL
        THEN CONVERT(INT, CONVERT(VARCHAR(8), ah.inv_date, 112))
        ELSE NULL
    END AS [InvoiceDate],
    CAST((coi.price * coi.qty_invoiced) AS DECIMAL(10,2)) AS [ExtSalesAmount],
    LEFT(coi.co_num, 30) AS [ERP_OrderNo],
    LEFT(coi.Uf_BENN_BoatSerialNumber, 15) AS [BoatSerialNo],
    LEFT(coi.Uf_BENN_BoatModel, 14) AS [BoatModelNo],
    ah.apply_to_inv_num AS [ApplyToNo],
    '' AS [ConfigID],                         -- Empty for physical items
    '' AS [ValueText],                        -- Empty for physical items
    co.order_date AS [order_date],
    co.external_confirmation_ref AS [external_confirmation_ref]
FROM [CSISTG].[dbo].[coitem_mst] coi
LEFT JOIN [CSISTG].[dbo].[inv_item_mst] iim
    ON coi.co_num = iim.co_num
    AND coi.co_line = iim.co_line
    AND coi.co_release = iim.co_release
    AND coi.site_ref = iim.site_ref
LEFT JOIN [CSISTG].[dbo].[arinv_mst] ah
    ON iim.inv_num = ah.inv_num
    AND iim.site_ref = ah.site_ref
LEFT JOIN [CSISTG].[dbo].[co_mst] co
    ON coi.co_num = co.co_num
    AND coi.site_ref = co.site_ref
LEFT JOIN [CSISTG].[dbo].[item_mst] im
    ON coi.item = im.item
    AND coi.site_ref = im.site_ref
LEFT JOIN [CSISTG].[dbo].[prodcode_mst] pcm
    ON im.Uf_BENN_MaterialCostType = pcm.product_code
    AND im.site_ref = pcm.site_ref
LEFT JOIN [CSISTG].[dbo].[serial_mst] ser
    ON coi.co_num = ser.ref_num
    AND coi.co_line = ser.ref_line
    AND coi.co_release = ser.ref_release
    AND coi.item = ser.item
    AND coi.site_ref = ser.site_ref
    AND ser.ref_type = 'O'
WHERE coi.site_ref = 'BENN'
    AND coi.Uf_BENN_BoatSerialNumber IS NOT NULL    -- Must have serial number
    AND coi.Uf_BENN_BoatSerialNumber != ''
    AND iim.inv_num IS NOT NULL                      -- Must be invoiced
    AND coi.qty_invoiced > 0
    AND co.order_date >= '2025-12-14'                -- CPQ go-live date
```

**What Part 1 Captures:**
- Physical items with serial numbers
- Must be invoiced (`inv_num IS NOT NULL`)
- Requires `BoatSerialNumber` to be populated
- Links to `item_mst` for item details
- Links to `serial_mst` for serial numbers
- **ConfigID and ValueText are empty** (not applicable)

**Why CPQ Orders Don't Show in Part 1:**
- CPQ orders have **empty BoatSerialNumber**
- WHERE clause filters them out: `Uf_BENN_BoatSerialNumber IS NOT NULL`
- This is why we need Part 2!

### Part 2: Configured Components (CPQ Items)

```sql
UNION ALL

SELECT
    LEFT(coi.Uf_BENN_BoatWebOrderNumber, 30) AS [WebOrderNo],
    LEFT(im.Uf_BENN_Series, 5) AS [C_Series],
    coi.qty_invoiced AS [QuantitySold],
    LEFT(co.type, 1) AS [Orig_Ord_Type],
    LEFT(ser.ser_num, 12) AS [BoatModelNo],
    pcm.description AS [MCTDesc],
    coi.co_line AS [LineSeqNo],               -- ⚠️ Same value for all components!
    coi.co_line AS [LineNo],
    LEFT(ISNULL(ccm.comp_name, attr_detail.comp_id), 15) AS [ItemNo],  -- Component ID
    NULL AS [ItemMasterProdCatDesc],
    LEFT(im.Uf_BENN_ProductCategory, 3) AS [ItemMasterProdCat],
    LEFT(im.Uf_BENN_MaterialCostType, 10) AS [ItemMasterMCT],
    LEFT(attr_detail.attr_value, 30) AS [ItemDesc1],  -- From cfg_attr_mst
    LEFT(iim.inv_num, 30) AS [InvoiceNo],
    CASE
        WHEN ah.inv_date IS NOT NULL
        THEN CONVERT(INT, CONVERT(VARCHAR(8), ah.inv_date, 112))
        ELSE NULL
    END AS [InvoiceDate],
    CAST((coi.price * coi.qty_invoiced) AS DECIMAL(10,2)) AS [ExtSalesAmount],
    LEFT(coi.co_num, 30) AS [ERP_OrderNo],
    LEFT(coi.Uf_BENN_BoatSerialNumber, 15) AS [BoatSerialNo],  -- Empty for CPQ
    LEFT(coi.Uf_BENN_BoatModel, 14) AS [OptionSerialNo],
    ah.apply_to_inv_num AS [ApplyToNo],
    LEFT(coi.config_id, 30) AS [ConfigID],         -- ✅ Populated for CFG items
    LEFT(attr_detail.attr_value, 100) AS [ValueText],  -- ✅ Component description
    co.order_date AS [order_date],
    co.external_confirmation_ref AS [external_confirmation_ref]
FROM [CSISTG].[dbo].[coitem_mst] coi
INNER JOIN [CSISTG].[dbo].[cfg_attr_mst] attr_detail    -- ⚠️ INNER JOIN to CFG tables
    ON coi.config_id = attr_detail.config_id
    AND coi.site_ref = attr_detail.site_ref
    AND attr_detail.attr_name = 'Description'           -- Only "Description" attributes
    AND attr_detail.sl_field = 'jobmatl.description'
    AND attr_detail.attr_type = 'Schema'
    AND attr_detail.attr_value IS NOT NULL
LEFT JOIN [CSISTG].[dbo].[cfg_comp_mst] ccm
    ON attr_detail.config_id = ccm.config_id
    AND attr_detail.comp_id = ccm.comp_id
    AND attr_detail.site_ref = ccm.site_ref
LEFT JOIN [CSISTG].[dbo].[inv_item_mst] iim
    ON coi.co_num = iim.co_num
    AND coi.co_line = iim.co_line
    AND coi.co_release = iim.co_release
    AND coi.site_ref = iim.site_ref
LEFT JOIN [CSISTG].[dbo].[arinv_mst] ah
    ON iim.inv_num = ah.inv_num
    AND iim.site_ref = ah.site_ref
LEFT JOIN [CSISTG].[dbo].[co_mst] co
    ON coi.co_num = co.co_num
    AND coi.site_ref = co.site_ref
LEFT JOIN [CSISTG].[dbo].[item_mst] im
    ON coi.item = im.item
    AND coi.site_ref = im.site_ref
LEFT JOIN [CSISTG].[dbo].[prodcode_mst] pcm
    ON im.Uf_BENN_MaterialCostType = pcm.product_code
    AND im.site_ref = pcm.site_ref
LEFT JOIN [CSISTG].[dbo].[serial_mst] ser
    ON coi.co_num = ser.ref_num
    AND coi.co_line = ser.ref_line
    AND coi.co_release = ser.ref_release
    AND coi.item = ser.item
    AND coi.site_ref = ser.site_ref
    AND ser.ref_type = 'O'
WHERE coi.config_id IS NOT NULL                -- Must have configuration ID
    AND coi.qty_invoiced = coi.qty_ordered     -- Must be fully invoiced
    AND coi.qty_invoiced > 0
    AND coi.site_ref = 'BENN'
    AND co.order_date >= '2025-12-14'          -- CPQ go-live date
```

**What Part 2 Captures:**
- Configured CPQ components from `cfg_attr_mst`
- Only items with `config_id` populated
- INNER JOIN on cfg tables (only gets configured items)
- Filters for `attr_name = 'Description'` (the component name/description)
- **Does NOT require BoatSerialNumber** (allows empty)
- ItemNo comes from `comp_id` (not item_mst)
- ValueText contains the component description

**Key Differences from Part 1:**
- Uses `cfg_attr_mst` and `cfg_comp_mst` tables
- No requirement for serial number
- ConfigID is populated
- All components share same `co_line` value (typically 1)

---

## The Configuration Tables (CFG)

### cfg_attr_mst: Configuration Attributes

Stores attributes for each component in a configuration.

**Structure:**
```
config_id          | comp_id              | attr_name   | attr_value            | sl_field
--------------------|----------------------|-------------|----------------------|-------------------
BENN...0052        | LADDER_21            | Description | LADDER 21 NON EXT... | jobmatl.description
BENN...0052        | S_FURN_CAPT_STD      | Description | S-RECLINER STANDARD  | jobmatl.description
BENN...0052        | LADDER_21            | Quantity    | 1                    | jobmatl.qty_req
BENN...0052        | S_FURN_CAPT_STD      | Quantity    | 2                    | jobmatl.qty_req
```

**Our Query:**
- Filters for `attr_name = 'Description'` only
- Each component with a Description attribute becomes one row
- This is why we get 46 rows for one order line (46 components with descriptions)

### cfg_comp_mst: Configuration Components

Stores component definitions (optional - provides friendly names).

**Structure:**
```
config_id          | comp_id              | comp_name
--------------------|----------------------|------------------
BENN...0052        | LADDER_21            | LADDER_21
BENN...0052        | S_FURN_CAPT_STD      | S_FURN_CAPT_STD
```

**Our Query:**
- LEFT JOIN (optional)
- Uses `ISNULL(ccm.comp_name, attr_detail.comp_id)` to get component name
- Falls back to comp_id if comp_name not available

---

## Critical Observations & Mysteries

### 1. All Components Share co_line = 1

**Observation:**
```
SO00936047, Line 1, config_id = BENN...0043
  ├─ Component 1: LADDER_21 (co_line = 1)
  ├─ Component 2: 168SLJ_FURN_SB_ (co_line = 1)
  ├─ Component 3: S_FURN_CAPT_STD (co_line = 1)
  └─ ... (all 46 components have co_line = 1)
```

**Why This Happens:**
- In Syteline, a configured item is treated as a single order line
- The configuration is stored externally in cfg tables
- coitem_mst only has one row with config_id
- All components are children of that single line

**The Problem This Caused:**
- Original import used `co_line` as LineSeqNo
- All components had LineSeqNo = 1
- Primary key collision: (ERP_OrderNo, 1)
- Only last component survived

**The Fix:**
- Use ROW_NUMBER() to generate unique LineSeqNo
- Each component gets sequential number: 1, 2, 3, 4...

### 2. Empty BoatSerialNo on Invoiced Orders

**Observation:**
```
ERP_OrderNo: SO00936047
InvoiceNo: [HAS VALUE]
InvoiceDate: 20260116
BoatSerialNo: [EMPTY]
```

**Questions:**
- Why are orders invoiced without serial numbers?
- When does serial assignment happen?
- Is this valid or a data quality issue?
- How do we track the physical boat?

### 3. Uniform Pricing Across All Components

**Observation:**
```
SO00936067 (50 components):
  Component 1: ExtSalesAmount = $32,757.00
  Component 2: ExtSalesAmount = $32,757.00
  Component 3: ExtSalesAmount = $32,757.00
  ... all 50 show $32,757.00

  Total: 50 × $32,757 = $1,637,850
```

**Possible Explanations:**

**Theory 1: Total Price Replication**
- ERP stores total config price in `coi.price`
- Query multiplies: `coi.price * coi.qty_invoiced`
- Same price applied to every component
- Should we divide by component count?

**Theory 2: Price Per Component Type**
- All components of certain type have same price
- Coincidentally multiple components at $32,757
- Need to investigate coitem_mst.price field

**Theory 3: Data Issue**
- Price not properly distributed across components
- ERP bug or misconfiguration
- Need to verify with business team

### 4. ConfigID Shared Across All Components

**Observation:**
```
SO00936067:
  All 50 components → config_id = BENN00000000000000000000000052

SO00936047:
  All 46 components → config_id = BENN00000000000000000000000043
```

**This is CORRECT:**
- One configuration ID per order line
- Multiple components belong to that configuration
- ConfigID links all components together
- Similar to a "bill of materials" or "assembly"

### 5. The Mystery of order_date and external_confirmation_ref

**Observation:**
```
Order: SO00936067
order_date: 2026-02-02
external_confirmation_ref: SOBHO00709
```

**What These Fields Mean:**

**order_date:**
- From `co_mst.order_date`
- Date the order was created in ERP
- Used for CPQ detection (>= 2025-12-14)
- Determines if order should be considered CPQ

**external_confirmation_ref:**
- CPQ-generated order number
- Format: SOBHO#####
- Links ERP order back to CPQ system
- Used for CPQ detection (starts with 'SO')

**CPQ Detection Logic:**
```python
def is_cpq_order(order_date, external_confirmation_ref, co_num):
    return (
        order_date >= date(2025, 12, 14) and    # After CPQ go-live
        co_num.startswith('SO') and             # Sales order format
        external_confirmation_ref.startswith('SO')  # CPQ reference
    )
```

---

## Data Integrity Concerns

### 1. Missing Serial Numbers

**Issue:** CPQ orders invoiced without BoatSerialNo

**Impact:**
- Cannot link to physical boats
- Cannot determine model year from serial
- Defaulting to 2026 (may be incorrect)

**Questions:**
- Is this temporary (serial assigned later)?
- Should invoice be blocked until serial assigned?
- How do we backfill serial numbers?

### 2. Price Replication

**Issue:** Same price on all components ($2.5M for 2 boats)

**Impact:**
- Inflated totals in reporting
- Cannot analyze component-level costs
- May affect margin calculations

**Questions:**
- Is this how ERP is designed?
- Should we aggregate by ConfigID?
- Need individual component pricing?

### 3. No Physical Items in CPQ Orders

**Issue:** Part 1 returns 0 rows, Part 2 returns 96 rows

**Impact:**
- Only getting configured components
- Missing any physical items that might exist
- May be incomplete picture of order

**Questions:**
- Should CPQ orders have physical line items?
- Are we missing boats/engines from Part 1?
- Is this the complete order data?

---

## Recommendations

### Immediate Actions

1. **Investigate Serial Number Workflow**
   - When/how are serial numbers assigned to CPQ orders?
   - Is empty serial on invoice acceptable?
   - Document the complete lifecycle

2. **Validate Pricing Logic**
   - Check coitem_mst.price field in MSSQL
   - Confirm if price replication is expected
   - Determine correct aggregation method

3. **Audit Data Completeness**
   - Verify Part 1 should return 0 rows for CPQ
   - Check if physical items exist but are filtered out
   - Confirm we're capturing complete order data

### Process Improvements

4. **Add Data Quality Checks**
   - Alert on empty serial numbers for invoiced orders
   - Validate price distribution across components
   - Check for orphaned configuration data

5. **Document ERP Workflows**
   - Map complete order-to-delivery process
   - Identify when each field gets populated
   - Create data dictionary for all Uf_BENN_ fields

6. **Consider Alternative Queries**
   - Explore other tables for serial numbers (jobserial_mst?)
   - Check for component pricing tables
   - Look for configuration summary/header tables

---

## Next Steps

1. **Schedule meeting with ERP team** to review findings
2. **Investigate MSSQL database directly** (query coitem_mst, cfg tables)
3. **Compare with C# code** - verify our understanding matches original intent
4. **Test with more orders** - validate patterns across larger dataset
5. **Document missing pieces** - serial assignment, pricing, component sourcing

---

## Glossary

**Terms:**

- **CPQ:** Configure-Price-Quote - Web-based boat configurator
- **ERP:** Enterprise Resource Planning - Syteline system
- **co_num:** Customer Order Number (e.g., SO00936047)
- **co_line:** Customer Order Line Number (sequence within order)
- **config_id:** Configuration ID from CPQ system
- **comp_id:** Component ID within a configuration
- **attr_name:** Attribute name in configuration (e.g., Description, Quantity)
- **ser_num:** Serial Number of physical boat
- **site_ref:** Site reference (always 'BENN' for Bennington)

**Table Prefixes:**

- **co_** : Customer Order
- **inv_** : Invoice
- **cfg_** : Configuration
- **Uf_BENN_** : User Field - Bennington custom fields

---

## Summary

The MSSQL database uses a complex structure to store CPQ orders differently from traditional orders:

1. **Traditional orders** → Simple lines in coitem_mst with items and serial numbers
2. **CPQ orders** → Single line with config_id pointing to multiple components in cfg tables

Our UNION query captures both types, but CPQ orders present unique challenges:
- Empty serial numbers (can't determine model year)
- Replicated pricing (can't calculate component costs)
- Shared line numbers (required ROW_NUMBER() fix)

**The key insight:** CPQ orders are fundamentally different from traditional orders in the ERP, requiring special handling throughout the entire data pipeline.
